{"version":3,"file":"extension.js","mappings":"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","sources":["webpack://typestack/webpack/runtime/require chunk loading","webpack://typestack/./src/codeCompletion.ts","webpack://typestack/./src/codeRunning.ts","webpack://typestack/./src/diagnostics.ts","webpack://typestack/./node_modules/typestack-lang/dist/modules/ lazy ^\\.\\/.*\\.js$ strict namespace object","webpack://typestack/external commonjs \"vscode\"","webpack://typestack/external node-commonjs \"readline\"","webpack://typestack/./node_modules/typestack-lang/dist/functions.js","webpack://typestack/./node_modules/typestack-lang/dist/parse.js","webpack://typestack/./node_modules/typestack-lang/dist/scan.js","webpack://typestack/./node_modules/typestack-lang/dist/stack.js","webpack://typestack/./node_modules/typestack-lang/dist/typeCheck.js","webpack://typestack/./node_modules/typestack-lang/dist/utils/consoleEffect.js","webpack://typestack/./node_modules/typestack-lang/dist/utils/error.js","webpack://typestack/./node_modules/typestack-lang/dist/utils/includes.js","webpack://typestack/webpack/bootstrap","webpack://typestack/webpack/runtime/define property getters","webpack://typestack/webpack/runtime/ensure chunk","webpack://typestack/webpack/runtime/get javascript chunk filename","webpack://typestack/webpack/runtime/hasOwnProperty shorthand","webpack://typestack/webpack/runtime/make namespace object","webpack://typestack/./src/extension.ts"],"sourcesContent":["// no baseURI\n\n// object to store loaded chunks\n// \"1\" means \"loaded\", otherwise not loaded yet\nvar installedChunks = {\n\t179: 1\n};\n\n// no on chunks loaded\n\nvar installChunk = (chunk) => {\n\tvar moreModules = chunk.modules, chunkIds = chunk.ids, runtime = chunk.runtime;\n\tfor(var moduleId in moreModules) {\n\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t}\n\t}\n\tif(runtime) runtime(__webpack_require__);\n\tfor(var i = 0; i < chunkIds.length; i++)\n\t\tinstalledChunks[chunkIds[i]] = 1;\n\n};\n\n// require() chunk loading for javascript\n__webpack_require__.f.require = (chunkId, promises) => {\n\t// \"1\" is the signal for \"already loaded\"\n\tif(!installedChunks[chunkId]) {\n\t\tif(true) { // all chunks have JS\n\t\t\tinstallChunk(require(\"./\" + __webpack_require__.u(chunkId)));\n\t\t} else installedChunks[chunkId] = 1;\n\t}\n};\n\n// no external install chunk\n\n// no HMR\n\n// no HMR manifest","import * as vscode from \"vscode\";\nimport { Scanner } from \"typestack-lang/dist/scan\";\nimport { Parser } from \"typestack-lang/dist/parse\";\nimport { standardLibraryFunctions } from \"typestack-lang/dist/functions\";\n\nexport default function activate(context: vscode.ExtensionContext) {\n  const provider1 = vscode.languages.registerCompletionItemProvider(\n    \"typestack\",\n    {\n      async provideCompletionItems(\n        document: vscode.TextDocument,\n        position: vscode.Position,\n        token: vscode.CancellationToken,\n        context: vscode.CompletionContext\n      ) {\n        //TODO: use position and document to provide different suggestions (functions, @int, continue/break, import ...)\n\n        const keywords = [\n          \"import\",\n          \"fn\",\n          \"loop\",\n          \"for\",\n          \"while\",\n          \"if\",\n          \"else\",\n          \"break\",\n          \"continue\",\n          \"int\",\n          \"bool\",\n          \"str\",\n          \"float\",\n          \"any\",\n          \"@int\",\n          \"@float\",\n          \"@str\",\n          \"@bool\",\n          \"@any\",\n          \"true\",\n          \"false\",\n        ];\n        const keywordCompletions = keywords.map(\n          (e) => new vscode.CompletionItem(e, vscode.CompletionItemKind.Keyword)\n        );\n\n        const scanner = new Scanner(document.getText(), console.log);\n        scanner.scan();\n        const parser = new Parser(scanner.tokens, standardLibraryFunctions);\n        await parser.parse();\n\n        const functions = parser.functions;\n        const functionNames: string[] = [];\n\n        Object.keys(functions).forEach((e) =>\n          Object.keys(functions[e as keyof typeof functions]).forEach(\n            (funcName) => {\n              functionNames.push(funcName);\n            }\n          )\n        );\n        const uniqueFunctionNames = [...new Set(functionNames)];\n        const functionCompletions = uniqueFunctionNames.map(\n          (e) =>\n            new vscode.CompletionItem(e, vscode.CompletionItemKind.Function)\n        );\n\n        /*\n\t\t\t// a completion item that inserts its text as snippet,\n\t\t\t// the `insertText`-property is a `SnippetString` which will be\n\t\t\t// honored by the editor.\n\t\t\tconst snippetCompletion = new vscode.CompletionItem('Good part of the day');\n\t\t\tsnippetCompletion.insertText = new vscode.SnippetString('Good ${1|morning,afternoon,evening|}. It is ${1}, right?');\n\t\t\tconst docs: any = new vscode.MarkdownString(\"Inserts a snippet that lets you select [link](x.ts).\");\n\t\t\tsnippetCompletion.documentation = docs;\n\t\t\tdocs.baseUri = vscode.Uri.parse('http://example.com/a/b/c/');\n\n\t\t\t// a completion item that retriggers IntelliSense when being accepted,\n\t\t\t// the `command`-property is set which the editor will execute after \n\t\t\t// completion has been inserted. Also, the `insertText` is set so that \n\t\t\t// a space is inserted after `new`\n\t\t\tconst commandCompletion = new vscode.CompletionItem('new');\n\t\t\tcommandCompletion.kind = vscode.CompletionItemKind.Keyword;\n\t\t\tcommandCompletion.insertText = 'new ';\n\t\t\tcommandCompletion.command = { command: 'editor.action.triggerSuggest', title: 'Re-trigger completions...' };\n            */\n\n        // return all completion items as array\n        return [...keywordCompletions, ...functionCompletions];\n      },\n    }\n  );\n\n  context.subscriptions.push(provider1);\n}\n","import * as vscode from \"vscode\";\n\nexport default function activate(context: vscode.ExtensionContext) {\n  context.subscriptions.push(\n    vscode.commands.registerCommand(\"typestack.run\", async () => {\n      try {\n        vscode.window.terminals[0].show();\n        const trySave = await vscode.window.activeTextEditor?.document?.save();\n        if (!trySave) {\n          throw new Error();\n        }\n        (\n          vscode.window.activeTerminal || vscode.window.createTerminal()\n        ).sendText(\n          \"typestack \" + vscode.window.activeTextEditor?.document?.fileName\n        );\n      } catch (e) {\n        vscode.window.showErrorMessage(\"Unable to run code.\");\n      }\n    })\n  );\n}\n","import * as vscode from \"vscode\";\nimport { Scanner } from \"typestack-lang/dist/scan\";\nimport { Parser } from \"typestack-lang/dist/parse\";\nimport typeCheck from \"typestack-lang/dist/typeCheck\";\nimport { standardLibraryFunctions } from \"typestack-lang/dist/functions\";\nimport { TSError } from \"typestack-lang/dist/utils/error\";\n\nexport async function refreshDiagnostics(\n  doc: vscode.TextDocument,\n  diagnosticCollection: vscode.DiagnosticCollection\n) {\n  const diagnostics: vscode.Diagnostic[] = [];\n  const fileText = doc.getText();\n  const errors = await getErrors(fileText);\n\n  if (errors) {\n    if (errors instanceof TSError) {\n      diagnostics.push(createDiagnostic(doc, errors));\n    } else {\n      errors.forEach((error) => {\n        diagnostics.push(createDiagnostic(doc, error));\n      });\n    }\n  }\n\n  diagnosticCollection.set(doc.uri, diagnostics);\n}\n\nfunction createDiagnostic(\n  doc: vscode.TextDocument,\n  error: TSError\n): vscode.Diagnostic {\n  // create range that represents, where in the document the word is\n  let errorLength = error.pos.endPos.char - error.pos.startPos.char;\n  if (errorLength === 0) {\n    errorLength = 1;\n  }\n  const range = new vscode.Range(\n    error.pos.startPos.line - 1,\n    error.pos.startPos.char - 1,\n    error.pos.endPos.line - 1,\n    error.pos.startPos.char - 1 + errorLength\n  );\n\n  const diagnostic = new vscode.Diagnostic(\n    range,\n    error.message,\n    vscode.DiagnosticSeverity.Error\n  );\n  diagnostic.code = \"typestack\";\n  return diagnostic;\n}\n\nexport function subscribeToDocumentChanges(\n  context: vscode.ExtensionContext,\n  diagnosticCollection: vscode.DiagnosticCollection\n): void {\n  if (vscode.window.activeTextEditor) {\n    refreshDiagnostics(\n      vscode.window.activeTextEditor.document,\n      diagnosticCollection\n    );\n  }\n  context.subscriptions.push(\n    vscode.window.onDidChangeActiveTextEditor((editor) => {\n      if (editor) {\n        refreshDiagnostics(editor.document, diagnosticCollection);\n      }\n    })\n  );\n\n  context.subscriptions.push(\n    vscode.workspace.onDidChangeTextDocument((e) =>\n      refreshDiagnostics(e.document, diagnosticCollection)\n    )\n  );\n\n  context.subscriptions.push(\n    vscode.workspace.onDidCloseTextDocument((doc) =>\n      diagnosticCollection.delete(doc.uri)\n    )\n  );\n}\n\nasync function getErrors(text: string): Promise<TSError | void | TSError[]> {\n  const scanner = new Scanner(text, console.log);\n  const scanErrors = scanner.scan();\n\n  const parser = new Parser(scanner.tokens, standardLibraryFunctions);\n  const parseErrors = await parser.parse();\n\n  return [\n    ...scanErrors,\n    ...parseErrors,\n    ...typeCheck(parser.program, standardLibraryFunctions, parser.newFunctions),\n  ];\n}\n","var map = {\n\t\"./Date.js\": [\n\t\t203,\n\t\t203\n\t],\n\t\"./Math.js\": [\n\t\t698,\n\t\t698\n\t],\n\t\"./Store.js\": [\n\t\t969,\n\t\t969\n\t],\n\t\"./Str.js\": [\n\t\t538,\n\t\t538\n\t]\n};\nfunction webpackAsyncContext(req) {\n\tif(!__webpack_require__.o(map, req)) {\n\t\treturn Promise.resolve().then(() => {\n\t\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\t\te.code = 'MODULE_NOT_FOUND';\n\t\t\tthrow e;\n\t\t});\n\t}\n\n\tvar ids = map[req], id = ids[0];\n\treturn __webpack_require__.e(ids[1]).then(() => {\n\t\treturn __webpack_require__(id);\n\t});\n}\nwebpackAsyncContext.keys = () => (Object.keys(map));\nwebpackAsyncContext.id = 602;\nmodule.exports = webpackAsyncContext;","module.exports = require(\"vscode\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"readline\");","import * as readline from \"readline\";\nexport function functionToText(name, stack, func) {\n    const parameters = Object.keys(func.params).map((e) => `${e}: ${func.params[e]}`);\n    return `${name}(${parameters.join(\" \")}) @${stack}`;\n}\nexport const standardLibraryFunctions = {\n    int: {\n        // comparison functions\n        \"<\": {\n            params: { right: \"int\", left: \"int\" },\n            rawCode: (stacks, params) => {\n                stacks.bool.push(params.left < params.right);\n            },\n        },\n        \">\": {\n            params: { right: \"int\", left: \"int\" },\n            rawCode: (stacks, params) => {\n                stacks.bool.push(params.left > params.right);\n            },\n        },\n        \"<=\": {\n            params: { right: \"int\", left: \"int\" },\n            rawCode: (stacks, params) => {\n                stacks.bool.push(params.left <= params.right);\n            },\n        },\n        \">=\": {\n            params: { right: \"int\", left: \"int\" },\n            rawCode: (stacks, params) => {\n                stacks.bool.push(params.left >= params.right);\n            },\n        },\n        // math functions\n        \"+\": {\n            params: { right: \"int\", left: \"int\" },\n            rawCode: (stacks, params) => {\n                stacks.int.push(params.left + params.right);\n            },\n        },\n        \"-\": {\n            params: { right: \"int\", left: \"int\" },\n            rawCode: (stacks, params) => {\n                stacks.int.push(params.left - params.right);\n            },\n        },\n        \"*\": {\n            params: { right: \"int\", left: \"int\" },\n            rawCode: (stacks, params) => {\n                stacks.int.push(params.left * params.right);\n            },\n        },\n        \"/\": {\n            params: { right: \"int\", left: \"int\" },\n            rawCode: (stacks, params) => {\n                if (params.right === 0) {\n                    return new Error(\"divide by zero. `/(right: int, left: int)` must have `right` parameter not equal to `0`\");\n                }\n                stacks.float.push(params.left / params.right);\n            },\n        },\n        \"//\": {\n            params: { right: \"int\", left: \"int\" },\n            rawCode: (stacks, params) => {\n                if (params.right === 0) {\n                    return new Error(\"divide by zero. `//(right: int, left: int)` must have `right` parameter not equal to `0`\");\n                }\n                stacks.int.push(Math.floor(params.left / params.right));\n            },\n        },\n        \"%\": {\n            params: { right: \"int\", left: \"int\" },\n            rawCode: (stacks, params) => {\n                if (params.right === 0) {\n                    return new Error(\"divide by zero. `%(right: int, left: int)` must have `right` parameter not equal to `0`\");\n                }\n                stacks.int.push(params.left % params.right);\n            },\n        },\n        \"^\": {\n            params: { right: \"int\", left: \"int\" },\n            rawCode: (stacks, params) => {\n                stacks.int.push(params.left ^ params.right);\n            },\n        },\n        rand: {\n            params: { max: \"int\", min: \"int\" },\n            rawCode: (stacks, params) => {\n                stacks.int.push(Math.floor(Math.random() * (params.max - params.min + 1)) + params.min);\n            },\n        },\n        wait: {\n            params: { milliseconds: \"int\" },\n            rawCode: async (_, params) => {\n                await new Promise((resolve) => {\n                    setTimeout(() => {\n                        resolve(\"resolved\");\n                    }, params.milliseconds);\n                });\n            },\n        },\n    },\n    float: {\n        // comparison functions\n        \"<\": {\n            params: { right: \"float\", left: \"float\" },\n            rawCode: (stacks, params) => {\n                stacks.bool.push(params.left < params.right);\n            },\n        },\n        \">\": {\n            params: { right: \"float\", left: \"float\" },\n            rawCode: (stacks, params) => {\n                stacks.bool.push(params.left > params.right);\n            },\n        },\n        \"<=\": {\n            params: { right: \"float\", left: \"float\" },\n            rawCode: (stacks, params) => {\n                stacks.bool.push(params.left <= params.right);\n            },\n        },\n        \">=\": {\n            params: { right: \"float\", left: \"float\" },\n            rawCode: (stacks, params) => {\n                stacks.bool.push(params.left >= params.right);\n            },\n        },\n        // math functions\n        \"+\": {\n            params: { right: \"float\", left: \"float\" },\n            rawCode: (stacks, params) => {\n                stacks.float.push(params.left + params.right);\n            },\n        },\n        \"-\": {\n            params: { right: \"float\", left: \"float\" },\n            rawCode: (stacks, params) => {\n                stacks.float.push(params.left - params.right);\n            },\n        },\n        \"*\": {\n            params: { right: \"float\", left: \"float\" },\n            rawCode: (stacks, params) => {\n                stacks.float.push(params.left * params.right);\n            },\n        },\n        \"/\": {\n            params: { right: \"float\", left: \"float\" },\n            rawCode: (stacks, params) => {\n                if (params.right === 0) {\n                    return new Error(\"divide by zero. `/(right: float, left: float)` must have `right` parameter not equal to `0.0`\");\n                }\n                stacks.float.push(params.left / params.right);\n            },\n        },\n        \"//\": {\n            params: { right: \"float\", left: \"float\" },\n            rawCode: (stacks, params) => {\n                if (params.right === 0) {\n                    return new Error(\"divide by zero. `//(right: float, left: float)` must have `right` parameter not equal to `0.0`\");\n                }\n                stacks.float.push(Math.floor(params.left * params.right));\n            },\n        },\n        \"%\": {\n            params: { right: \"float\", left: \"float\" },\n            rawCode: (stacks, params) => {\n                if (params.right === 0) {\n                    return new Error(\"divide by zero. `%(right: float, left: float)` must have `right` parameter not equal to `0.0`\");\n                }\n                stacks.int.push(params.left % params.right);\n            },\n        },\n        \"^\": {\n            params: { right: \"float\", left: \"float\" },\n            rawCode: (stacks, params) => {\n                stacks.float.push(params.left ^ params.right);\n            },\n        },\n    },\n    str: {\n        length: {\n            params: { string: \"str\" },\n            rawCode: (stacks, params) => {\n                stacks.int.push(params.str.length);\n            },\n        },\n        \"+\": {\n            params: { right: \"str\", left: \"str\" },\n            rawCode: (stacks, params) => {\n                stacks.str.push(params.left + params.right);\n            },\n        },\n    },\n    bool: {\n        // comparison functions\n        \"&\": {\n            params: { right: \"bool\", left: \"bool\" },\n            rawCode: (stacks, params) => {\n                stacks.bool.push(params.left && params.right);\n            },\n        },\n        \"|\": {\n            params: { right: \"bool\", left: \"bool\" },\n            rawCode: (stacks, params) => {\n                stacks.bool.push(params.left || params.right);\n            },\n        },\n        \"!\": {\n            params: { boolean: \"bool\" },\n            rawCode: (stacks, params) => {\n                stacks.bool.push(!params.boolean);\n            },\n        },\n    },\n    any: {\n        // Word functions\n        dup: {\n            params: { first: \"any\" },\n            rawCode: (stacks, params, stack) => {\n                stacks[stack].push(params.first);\n                stacks[stack].push(params.first);\n            },\n        },\n        drop: {\n            params: { first: \"any\" },\n        },\n        swap: {\n            params: { first: \"any\", second: \"any\" },\n            rawCode: (stacks, params, stack) => {\n                stacks[stack].push(params.first);\n                stacks[stack].push(params.second);\n            },\n        },\n        over: {\n            params: { first: \"any\", second: \"any\" },\n            rawCode: (stacks, params, stack) => {\n                stacks[stack].push(params.second);\n                stacks[stack].push(params.first);\n                stacks[stack].push(params.second);\n            },\n        },\n        rot: {\n            params: {\n                first: \"any\",\n                second: \"any\",\n                third: \"any\",\n            },\n            rawCode: (stacks, params, stack) => {\n                stacks[stack].push(params.second);\n                stacks[stack].push(params.first);\n                stacks[stack].push(params.third);\n            },\n        },\n        print: {\n            params: { item: \"any\" },\n            rawCode: (stacks, params, stack, consoleFunc) => {\n                if (stack === \"float\" && !params.item.toString().includes(\".\")) {\n                    params.item = params.item.toFixed(1);\n                }\n                consoleFunc(params.item.toString());\n                stacks[stack].push(params.item);\n            },\n        },\n        read: {\n            params: { prompt: \"str\" },\n            rawCode: async (stacks, params, stack) => {\n                // does not work on browser\n                if (typeof window !== \"undefined\") {\n                    return;\n                }\n                const rl = readline.createInterface({\n                    input: process.stdin,\n                    output: process.stdout,\n                });\n                const answer = await new Promise((resolve) => {\n                    rl.question(params.prompt, resolve);\n                });\n                rl.close();\n                if (stack === \"str\") {\n                    stacks[stack].push(answer);\n                }\n                else if (stack === \"bool\") {\n                    if (answer.trim() === \"true\") {\n                        stacks[stack].push(true);\n                    }\n                    else if (answer.trim() === \"false\") {\n                        stacks[stack].push(false);\n                    }\n                    else {\n                        return new Error(`invalid input for type \\`${stack}\\`: \\`${answer}\\``);\n                    }\n                }\n                else {\n                    // int or float\n                    const isFloat = stack === \"float\";\n                    let isInDecimal = false;\n                    for (const char of answer.trim().split(\"\")) {\n                        if (char === \".\") {\n                            if (isInDecimal || !isFloat) {\n                                return new Error(`invalid input for type \\`${stack}\\`: \\`${answer}\\``);\n                            }\n                            else {\n                                isInDecimal = true;\n                                continue;\n                            }\n                        }\n                        if (!(char >= \"0\" && char <= \"9\")) {\n                            return new Error(`invalid input for type \\`${stack}\\`: \\`${answer}\\``);\n                        }\n                    }\n                    if (isFloat) {\n                        stacks[stack].push(parseFloat(answer));\n                    }\n                    else {\n                        stacks[stack].push(parseInt(answer));\n                    }\n                }\n            },\n        },\n        // comparison functions\n        \"==\": {\n            params: { right: \"any\", left: \"any\" },\n            rawCode: (stacks, params) => {\n                stacks.bool.push(params.left === params.right);\n            },\n        },\n        \"!=\": {\n            params: { right: \"any\", left: \"any\" },\n            rawCode: (stacks, params) => {\n                stacks.bool.push(params.left !== params.right);\n            },\n        },\n        // conversion functions\n        toStr: {\n            params: { item: \"any\" },\n            rawCode: (stacks, params, stack) => {\n                if (stack === \"float\" && !params.item.toString().includes(\".\")) {\n                    params.item = params.item.toFixed(1);\n                }\n                stacks.str.push(params.item.toString());\n            },\n        },\n        toBool: {\n            params: { item: \"any\" },\n            rawCode: (stacks, params) => {\n                stacks.bool.push(!!params.item);\n            },\n        },\n        toInt: {\n            params: { item: \"any\" },\n            rawCode: (stacks, params, stack) => {\n                let int;\n                if (stack === \"int\") {\n                    int = params.item;\n                }\n                else if (stack === \"float\") {\n                    int = Math.trunc(params.item);\n                }\n                else if (stack === \"bool\") {\n                    int = params.item ? 1 : 0;\n                }\n                else {\n                    for (const char of params.item.split(\"\")) {\n                        if (!(char >= \"0\" && char <= \"9\")) {\n                            return new Error(`unable to convert \\`str\\` to \\`int\\`: \\`${params.item}\\``);\n                        }\n                    }\n                    int = parseInt(params.item);\n                }\n                stacks.int.push(int);\n            },\n        },\n        toFloat: {\n            params: { item: \"any\" },\n            rawCode: (stacks, params, stack) => {\n                let float;\n                if (stack === \"float\" || stack === \"int\") {\n                    float = params.item;\n                }\n                else if (stack === \"bool\") {\n                    float = params.item ? 1 : 0;\n                }\n                else {\n                    let isInDecimal = false;\n                    for (const char of params.item.split(\"\")) {\n                        if (char === \".\") {\n                            if (isInDecimal) {\n                                return new Error(`unable to convert \\`str\\` to \\`float\\`: \\`${params.item}\\``);\n                            }\n                            else {\n                                isInDecimal = true;\n                                continue;\n                            }\n                        }\n                        if (!(char >= \"0\" && char <= \"9\")) {\n                            return new Error(`unable to convert \\`str\\` to \\`float\\`: \\`${params.item}\\``);\n                        }\n                    }\n                    float = parseFloat(params.item);\n                }\n                stacks.float.push(float);\n            },\n        },\n    },\n};\n","import { stackTypes } from \"./stack.js\";\nimport { TSError } from \"./utils/error.js\";\nimport includes from \"./utils/includes.js\";\nexport class Parser {\n    tokens;\n    pointer;\n    functions;\n    newFunctions;\n    program;\n    errors;\n    constructor(tokens, functions) {\n        this.tokens = tokens;\n        this.functions = functions;\n        this.newFunctions = [];\n        this.pointer = 0;\n        this.program = [];\n        this.errors = [];\n    }\n    async parse() {\n        await this.#parseImports();\n        const block = this.#parseStatement(true);\n        this.program = block;\n        return this.errors;\n    }\n    async #parseImports() {\n        this.#decrement();\n        while (this.pointer < 0 || !this.#isAtEnd()) {\n            if (this.#expect(\"keyword\", \"import\")) {\n                this.#increment();\n                if (this.#expect(\"identifier\")) {\n                    this.#increment();\n                    // dynamically import the file and add the module functions to the functions\n                    try {\n                        const module = (await import(`./modules/${this.#peek().value}.js`))\n                            .default;\n                        for (const stack of stackTypes) {\n                            for (const key in module[stack]) {\n                                this.functions[stack][this.#peek().value + \".\" + key] =\n                                    module[stack][key];\n                            }\n                        }\n                    }\n                    catch (_) {\n                        this.errors.push(new TSError({\n                            startPos: this.#peek().startPos,\n                            endPos: this.#peek().endPos,\n                        }, \"unable to import module\"));\n                    }\n                }\n                else {\n                    this.#increment();\n                    this.errors.push(new TSError({\n                        startPos: this.#peek().startPos,\n                        endPos: this.#peek().endPos,\n                    }, \"expected an identifier after an `import` keyword\"));\n                    this.#decrement();\n                }\n            }\n            else {\n                this.#increment();\n                return;\n            }\n        }\n    }\n    #parseStatement(isInRoot, isInLoop = false, isInFunction = false) {\n        // increment past the `{` character\n        if (!isInRoot && this.#peek().type === \"openBracket\") {\n            this.#increment();\n        }\n        const block = [];\n        while (!this.#isAtEnd()) {\n            const current = this.#peek();\n            // Punctuation should not be in the middle of nowhere\n            const puncTokens = [\"openBracket\", \"closeParen\", \"openParen\", \"colon\"];\n            if (includes(puncTokens, current.type)) {\n                this.errors.push(new TSError({\n                    startPos: current.startPos,\n                    endPos: current.endPos,\n                }, \"unexpected character\"));\n                this.#increment();\n                continue;\n            }\n            // literals become expressions\n            const literalTokens = [\n                \"int\",\n                \"float\",\n                \"str\",\n                \"bool\",\n                \"identifier\",\n            ];\n            if (includes(literalTokens, current.type)) {\n                block.push(current);\n                this.#increment();\n                continue;\n            }\n            // return the block when hitting a `}` unless in the root witch would be an error\n            if (\"closeBracket\" === current.type) {\n                if (isInRoot) {\n                    this.errors.push(new TSError({\n                        startPos: current.startPos,\n                        endPos: current.endPos,\n                    }, \"unexpected character\"));\n                    this.#increment();\n                    continue;\n                }\n                this.#increment();\n                return block;\n            }\n            if (\"keyword\" === current.type) {\n                // stack types become expressions\n                const mainTypeKeywords = [\"int\", \"str\", \"float\", \"bool\"];\n                if (includes(mainTypeKeywords, current.value)) {\n                    block.push(current);\n                    this.#increment();\n                    continue;\n                }\n                // At keyword are invalid\n                const atKeywords = [\"@int\", \"@bool\", \"@str\", \"@float\", \"@any\"];\n                if (includes(atKeywords, current.value)) {\n                    this.errors.push(new TSError({\n                        startPos: current.startPos,\n                        endPos: current.endPos,\n                    }, \"unexpected keyword `{}`. Keyword `{}` must only be found after parameters in a function declaration\", current.value, current.value));\n                    this.#increment();\n                    continue;\n                }\n                // else is invalid\n                if (\"else\" === current.value) {\n                    this.errors.push(new TSError({\n                        startPos: current.startPos,\n                        endPos: current.endPos,\n                    }, \"unexpected keyword `else`. Keyword `else` must only be found after if statements\"));\n                    this.#increment();\n                    continue;\n                }\n                // any can only be found in functions\n                if (\"any\" === current.value) {\n                    if (isInFunction) {\n                        block.push(current);\n                    }\n                    else {\n                        this.errors.push(new TSError({\n                            startPos: current.startPos,\n                            endPos: current.endPos,\n                        }, \"unexpected keyword `any`. Keyword `any` must only be found in `@any` functions\"));\n                    }\n                    this.#increment();\n                    continue;\n                }\n                // break can only be found in loops\n                if (\"break\" === current.value) {\n                    if (isInLoop) {\n                        block.push(current);\n                    }\n                    else {\n                        this.errors.push(new TSError({\n                            startPos: current.startPos,\n                            endPos: current.endPos,\n                        }, \"unexpected keyword `break`. Keyword `break` must only be found in loops\"));\n                    }\n                    this.#increment();\n                    continue;\n                }\n                // continue can only be found in loops\n                if (\"continue\" === current.value) {\n                    if (isInLoop) {\n                        block.push(current);\n                    }\n                    else {\n                        this.errors.push(new TSError({\n                            startPos: current.startPos,\n                            endPos: current.endPos,\n                        }, \"unexpected keyword `continue`. Keyword `continue` must only be found in loops\"));\n                    }\n                    this.#increment();\n                    continue;\n                }\n                // import is invalid unless at th top of the program\n                if (\"import\" === current.value) {\n                    this.errors.push(new TSError({\n                        startPos: current.startPos,\n                        endPos: current.endPos,\n                    }, \"unexpected keyword `import`. Keyword `import` must only be found at the top of programs\"));\n                    this.#increment();\n                    continue;\n                }\n                // parsing statements\n                if (\"loop\" === current.value) {\n                    const startPos = current.startPos;\n                    const endPos = current.endPos;\n                    // opening bracket should follow a loop keyword\n                    if (this.#expect(\"openBracket\")) {\n                        this.#increment();\n                    }\n                    else {\n                        this.#increment();\n                        this.errors.push(new TSError({\n                            startPos: this.#peek().startPos,\n                            endPos: this.#peek().endPos,\n                        }, \"expected an opening bracket `{` after a `loop` keyword\"));\n                    }\n                    const innerBlock = this.#parseStatement(false, true, isInFunction);\n                    block.push({\n                        startPos,\n                        endPos,\n                        type: \"loop\",\n                        block: innerBlock,\n                    });\n                    continue;\n                }\n                if (\"for\" === current.value) {\n                    const startPos = current.startPos;\n                    // loop and an opening bracket should follow a for keyword\n                    if (this.#expect(\"keyword\", \"loop\")) {\n                        this.#increment();\n                    }\n                    else {\n                        this.#increment();\n                        this.errors.push(new TSError({\n                            startPos: this.#peek().startPos,\n                            endPos: this.#peek().endPos,\n                        }, \"expected a `loop` keyword after a `for` keyword\"));\n                        this.#decrement();\n                    }\n                    const endPos = this.#peek().endPos;\n                    if (this.#expect(\"openBracket\")) {\n                        this.#increment();\n                    }\n                    else {\n                        this.#increment();\n                        this.errors.push(new TSError({\n                            startPos: this.#peek().startPos,\n                            endPos: this.#peek().endPos,\n                        }, \"expected an opening bracket `{` after a `loop` keyword\"));\n                    }\n                    const innerBlock = this.#parseStatement(false, true, isInFunction);\n                    block.push({\n                        startPos,\n                        endPos,\n                        type: \"forLoop\",\n                        block: innerBlock,\n                    });\n                    continue;\n                }\n                if (\"while\" === current.value) {\n                    const startPos = current.startPos;\n                    // loop and an opening bracket should follow a while keyword\n                    if (this.#expect(\"keyword\", \"loop\")) {\n                        this.#increment();\n                    }\n                    else {\n                        this.#increment();\n                        this.errors.push(new TSError({\n                            startPos: this.#peek().startPos,\n                            endPos: this.#peek().endPos,\n                        }, \"expected a `loop` keyword after a `while` keyword\"));\n                        this.#decrement();\n                    }\n                    const endPos = this.#peek().endPos;\n                    if (this.#expect(\"openBracket\")) {\n                        this.#increment();\n                    }\n                    else {\n                        this.#increment();\n                        this.errors.push(new TSError({\n                            startPos: this.#peek().startPos,\n                            endPos: this.#peek().endPos,\n                        }, \"expected an opening bracket `{` after a `loop` keyword\"));\n                    }\n                    const innerBlock = this.#parseStatement(false, true, isInFunction);\n                    block.push({\n                        startPos,\n                        endPos,\n                        type: \"whileLoop\",\n                        block: innerBlock,\n                    });\n                    continue;\n                }\n                if (\"if\" === current.value) {\n                    const startPos = current.startPos;\n                    const endPos = current.endPos;\n                    // an opening bracket should follow an if\n                    if (this.#expect(\"openBracket\")) {\n                        this.#increment();\n                    }\n                    else {\n                        this.#increment();\n                        this.errors.push(new TSError({\n                            startPos: this.#peek().startPos,\n                            endPos: this.#peek().endPos,\n                        }, \"expected an opening bracket `{` after an `if` keyword\"));\n                    }\n                    const innerBlock = this.#parseStatement(false, isInLoop, isInFunction);\n                    // an optional else keyword can follow with an opening bracket\n                    this.pointer -= 1;\n                    if (this.#expect(\"keyword\", \"else\")) {\n                        this.#increment();\n                        if (this.#expect(\"openBracket\")) {\n                            this.#increment();\n                        }\n                        else {\n                            this.#increment();\n                            this.errors.push(new TSError({\n                                startPos: this.#peek().startPos,\n                                endPos: this.#peek().endPos,\n                            }, \"expected an opening bracket `{` after an `else` keyword\"));\n                        }\n                        const elseBlock = this.#parseStatement(false, isInLoop, isInFunction);\n                        block.push({\n                            startPos,\n                            endPos,\n                            type: \"if\",\n                            block: innerBlock,\n                            else: elseBlock,\n                        });\n                        continue;\n                    }\n                    this.#increment();\n                    block.push({\n                        startPos,\n                        endPos,\n                        type: \"if\",\n                        block: innerBlock,\n                    });\n                    continue;\n                }\n                if (\"fn\" === current.value) {\n                    // functions must not be nestled\n                    if (!isInRoot) {\n                        this.errors.push(new TSError({\n                            startPos: current.startPos,\n                            endPos: current.endPos,\n                        }, \"unexpected `fn` keyword. Function declarations must not be nestled in other statements\"));\n                    }\n                    let isErrorWithFunction = false;\n                    // the name of the function (identifier) should follow\n                    if (this.#expect(\"identifier\")) {\n                        this.#increment();\n                    }\n                    else {\n                        // having an invalid identifier name will cause a problem with the function\n                        isErrorWithFunction = true;\n                        this.#increment();\n                        this.errors.push(new TSError({\n                            startPos: this.#peek().startPos,\n                            endPos: this.#peek().endPos,\n                        }, \"expected an identifier after a `fn` keyword\"));\n                        this.#decrement();\n                    }\n                    // the name of the function if there is no error\n                    const name = this.#peek().value;\n                    // an opening parenthesis should follow\n                    if (this.#expect(\"openParen\")) {\n                        this.#increment();\n                    }\n                    else {\n                        // forgetting an open paren will NOT cause a problem with the function\n                        this.#increment();\n                        this.errors.push(new TSError({\n                            startPos: this.#peek().startPos,\n                            endPos: this.#peek().endPos,\n                        }, \"expected an opening parenthesis `(` after a function identifier\"));\n                        this.#decrement();\n                    }\n                    const params = {};\n                    // get all the parameters from the function\n                    while (!this.#isAtEnd() &&\n                        !this.#expect(\"EOF\") &&\n                        !this.#expect(\"closeParen\") &&\n                        this.#peek().type !== \"closeParen\") {\n                        if (!this.#expect(\"identifier\")) {\n                            this.#increment();\n                            this.errors.push(new TSError({\n                                startPos: this.#peek().startPos,\n                                endPos: this.#peek().endPos,\n                            }, \"expected an identifier or closing bracket `)` within a function's opening bracket `(`\"));\n                            continue;\n                        }\n                        // name of the parameter\n                        this.#increment();\n                        const name = this.#peek().value;\n                        if (name in params) {\n                            this.errors.push(new TSError({\n                                startPos: this.#peek().startPos,\n                                endPos: this.#peek().endPos,\n                            }, \"duplicate parameter name. Function parameters must have unique names\"));\n                        }\n                        // parameters can have a type associated with them separated by a colon\n                        if (this.#expect(\"colon\")) {\n                            this.#increment();\n                            this.#increment();\n                            const typeKeywords = [\n                                \"int\",\n                                \"str\",\n                                \"float\",\n                                \"bool\",\n                                \"any\",\n                            ];\n                            if (this.#peek().type === \"keyword\" &&\n                                includes(typeKeywords, this.#peek().value)) {\n                                params[name] = this.#peek().value;\n                            }\n                            else {\n                                // a function without a type is not invalid\n                                this.errors.push(new TSError({\n                                    startPos: this.#peek().startPos,\n                                    endPos: this.#peek().endPos,\n                                }, \"expected a type `int`, `float`, `str`, `bool` or `any` after a colon for a function parameter\"));\n                                this.#decrement();\n                            }\n                        }\n                        else {\n                            // parameters without a colon are `any` type\n                            params[name] = \"any\";\n                        }\n                    }\n                    this.#increment();\n                    if (this.#isAtEnd()) {\n                        this.errors.push(new TSError({\n                            startPos: this.#peek().startPos,\n                            endPos: this.#peek().endPos,\n                        }, \"expected a closing parenthesis `)`\"));\n                    }\n                    else {\n                        this.#increment();\n                    }\n                    let functionType;\n                    // a function type should follow\n                    const atKeywords = [\"@int\", \"@bool\", \"@str\", \"@float\", \"@any\"];\n                    if (!this.#isAtEnd() &&\n                        this.#peek().type === \"keyword\" &&\n                        includes(atKeywords, this.#peek().value)) {\n                        const atKeywordToStackTypes = {\n                            \"@int\": \"int\",\n                            \"@float\": \"float\",\n                            \"@str\": \"str\",\n                            \"@bool\": \"bool\",\n                            \"@any\": \"any\",\n                        };\n                        functionType = atKeywordToStackTypes[this.#peek().value];\n                    }\n                    else {\n                        // a function without a type is invalid\n                        isErrorWithFunction = true;\n                        this.errors.push(new TSError({\n                            startPos: this.#peek().startPos,\n                            endPos: this.#peek().endPos,\n                        }, \"expected a `@int`, `@float`, `@str`, `@bool` or `@any` after function parameters\"));\n                        this.#decrement();\n                    }\n                    // finally, a opening bracket is needed\n                    if (this.#expect(\"openBracket\")) {\n                        this.#increment();\n                    }\n                    else {\n                        this.#increment();\n                        this.errors.push(new TSError({\n                            startPos: this.#peek().startPos,\n                            endPos: this.#peek().endPos,\n                        }, \"expected an opening bracket `{` after a `function` declaration\"));\n                    }\n                    const innerBlock = this.#parseStatement(false, isInLoop, true);\n                    if (!isErrorWithFunction) {\n                        this.newFunctions.push({\n                            name,\n                            type: functionType,\n                        });\n                        this.functions[functionType][name] = {\n                            params: params,\n                            body: innerBlock,\n                        };\n                    }\n                    continue;\n                }\n                this.errors.push(new TSError({\n                    startPos: current.startPos,\n                    endPos: current.endPos,\n                }, \"unknown keyword `{}`\", current.value));\n                this.#increment();\n                continue;\n            }\n            this.errors.push(new TSError({\n                startPos: current.startPos,\n                endPos: current.endPos,\n            }, \"unknown token `{}`\", current.value));\n            this.#increment();\n            continue;\n        }\n        if (this.#isAtEnd() && !isInRoot) {\n            this.errors.push(new TSError({\n                startPos: this.#peek().startPos,\n                endPos: this.#peek().endPos,\n            }, \"expected an ending bracket `}`\"));\n        }\n        return block;\n    }\n    #isAtEnd() {\n        return this.tokens[this.pointer].type === \"EOF\";\n    }\n    #peek() {\n        if (this.#isAtEnd()) {\n            return this.tokens[this.tokens.length - 1];\n        }\n        return this.tokens[this.pointer];\n    }\n    #increment() {\n        this.pointer += 1;\n    }\n    #decrement() {\n        this.pointer -= 1;\n    }\n    #expect(type, value) {\n        this.#increment();\n        if (this.#isAtEnd()) {\n            this.#decrement();\n            return type === \"EOF\";\n        }\n        const isExpected = this.#peek().type === type &&\n            (!value || (value && value === this.#peek().value));\n        this.#decrement();\n        return isExpected;\n    }\n}\n","import { TSError, ErrorInputConfig } from \"./utils/error.js\";\nconst keywords = [\n    \"import\",\n    \"fn\",\n    \"loop\",\n    \"for\",\n    \"while\",\n    \"if\",\n    \"else\",\n    \"break\",\n    \"continue\",\n    \"int\",\n    \"bool\",\n    \"str\",\n    \"float\",\n    \"any\",\n    \"@int\",\n    \"@float\",\n    \"@str\",\n    \"@bool\",\n    \"@any\",\n];\nexport class Scanner {\n    input;\n    tokens;\n    pointer;\n    char;\n    line;\n    errors;\n    constructor(input, consoleFunc) {\n        input = input.trimEnd();\n        ErrorInputConfig.input = input;\n        ErrorInputConfig.consoleFunc = consoleFunc;\n        this.input = input;\n        this.tokens = [];\n        this.pointer = 0;\n        this.char = 1;\n        this.line = 1;\n        this.errors = [];\n    }\n    scan() {\n        while (!this.#isAtEnd()) {\n            const current = this.#peek();\n            if ([\"(\", \")\", \"{\", \"}\", \":\"].includes(current)) {\n                switch (current) {\n                    case \"(\":\n                        this.#addToken(\"openParen\", \"(\");\n                        break;\n                    case \")\":\n                        this.#addToken(\"closeParen\", \")\");\n                        break;\n                    case \"{\":\n                        this.#addToken(\"openBracket\", \"{\");\n                        break;\n                    case \"}\":\n                        this.#addToken(\"closeBracket\", \"}\");\n                        break;\n                    case \":\":\n                        this.#addToken(\"colon\", \":\");\n                }\n                this.#increment();\n                continue;\n            }\n            if (\"#\" === current) {\n                while (!this.#isAtEnd() && this.#peek() !== \"\\n\") {\n                    this.#increment();\n                }\n                continue;\n            }\n            if ([\" \", \"\\t\", \"\\r\"].includes(current)) {\n                this.#increment();\n                continue;\n            }\n            if (\"\\n\" === current) {\n                this.#newline();\n                continue;\n            }\n            if ('\"' === current) {\n                const startPos = {\n                    line: this.line,\n                    char: this.char,\n                };\n                this.#increment();\n                let str = \"\";\n                while (!this.#isAtEnd() && this.#peek() !== '\"') {\n                    if (this.#peek() === \"\\\\\") {\n                        this.#increment();\n                        if (this.#peek() === \"\\\\\") {\n                            str += \"\\\\\";\n                        }\n                        else if (this.#peek() === \"n\") {\n                            str += \"\\n\";\n                        }\n                        else if (this.#peek() === \"r\") {\n                            str += \"\\r\";\n                        }\n                        else if (this.#peek() === \"t\") {\n                            str += \"\\t\";\n                        }\n                        else if (this.#peek() === '\"') {\n                            str += '\"';\n                        }\n                        else {\n                            this.errors.push(new TSError({\n                                startPos: { line: this.line, char: this.char - 1 },\n                                endPos: { line: this.line, char: this.char + 1 },\n                            }, \"unknown escape code\"));\n                        }\n                        this.#increment();\n                    }\n                    else {\n                        str += this.#peek();\n                        if (this.#peek() === \"\\n\") {\n                            this.#newline();\n                        }\n                        else {\n                            this.#increment();\n                        }\n                    }\n                }\n                if (this.#isAtEnd()) {\n                    this.errors.push(new TSError({\n                        startPos: startPos,\n                        endPos: { line: this.line, char: this.char },\n                    }, 'expected an ending string literal `\"`'));\n                }\n                this.#increment();\n                this.#addToken(\"str\", str, startPos);\n                this.#expectSeparator();\n                continue;\n            }\n            if (current >= \"0\" && current <= \"9\") {\n                this.#number();\n            }\n            else {\n                this.#identifier();\n            }\n        }\n        this.#increment();\n        this.#addToken(\"EOF\", \"\");\n        return this.errors;\n    }\n    #addToken(type, value, startPos = { line: this.line, char: this.char }, endPos = { line: this.line, char: this.char }) {\n        this.tokens.push({\n            type,\n            value,\n            startPos,\n            endPos,\n        });\n    }\n    #isAtEnd() {\n        return this.pointer >= this.input.length;\n    }\n    #peek() {\n        return this.input[this.pointer];\n    }\n    #increment() {\n        this.pointer += 1;\n        this.char += 1;\n    }\n    #newline() {\n        this.pointer += 1;\n        this.line += 1;\n        this.char = 1;\n    }\n    #expectSeparator() {\n        if (!this.#isAtEnd() &&\n            ![\"\\n\", \"\\r\", \"\\t\", \" \", \"{\", \"}\", \"(\", \")\", \":\", \"#\"].includes(this.#peek())) {\n            this.errors.push(new TSError({\n                startPos: { line: this.line, char: this.char },\n                endPos: { line: this.line, char: this.char + 1 },\n            }, \"Expected separator (`\\\\n`, `\\\\r`, `\\\\t`, ` `, `{`, `}`, `(`, `)`, `:`)\"));\n        }\n    }\n    #number() {\n        const startPos = {\n            line: this.line,\n            char: this.char,\n        };\n        let strOfNumber = \"\";\n        while (!this.#isAtEnd() && this.#peek() >= \"0\" && this.#peek() <= \"9\") {\n            strOfNumber += this.#peek();\n            this.#increment();\n        }\n        if (!this.#isAtEnd() && this.#peek() === \".\") {\n            strOfNumber += \".\";\n            this.#increment();\n            while (!this.#isAtEnd() && this.#peek() >= \"0\" && this.#peek() <= \"9\") {\n                strOfNumber += this.#peek();\n                this.#increment();\n            }\n            const float = parseFloat(strOfNumber);\n            if (Number.isNaN(float)) {\n                this.errors.push(new TSError({\n                    startPos: { line: startPos.line, char: startPos.char },\n                    endPos: { line: this.line, char: this.char },\n                }, \"Unable to parse float\"));\n            }\n            this.#addToken(\"float\", float, startPos);\n        }\n        else {\n            const int = parseInt(strOfNumber);\n            if (Number.isNaN(int)) {\n                this.errors.push(new TSError({\n                    startPos: { line: startPos.line, char: startPos.char },\n                    endPos: { line: this.line, char: this.char },\n                }, \"Unable to parse int\"));\n            }\n            this.#addToken(\"int\", int, startPos);\n        }\n        this.#expectSeparator();\n    }\n    #identifier() {\n        const startPos = {\n            line: this.line,\n            char: this.char,\n        };\n        let str = \"\";\n        while (!this.#isAtEnd() &&\n            ![\" \", \"\\n\", \"\\t\", \"\\r\", \":\", \"{\", \"}\", \"(\", \")\", \"#\"].includes(this.#peek())) {\n            str += this.#peek();\n            this.#increment();\n        }\n        if (str === \"false\") {\n            this.#addToken(\"bool\", false, startPos);\n        }\n        else if (str === \"true\") {\n            this.#addToken(\"bool\", true, startPos);\n        }\n        else if (keywords.some((e) => e === str)) {\n            this.#addToken(\"keyword\", str, startPos);\n        }\n        else {\n            this.#addToken(\"identifier\", str, startPos);\n        }\n    }\n}\n","export const stackTypes = [\"int\", \"float\", \"str\", \"bool\", \"any\"];\nexport class Stack {\n    stack;\n    constructor() {\n        this.stack = [];\n    }\n    push(t) {\n        this.stack.push(t);\n    }\n    get() {\n        return this.stack.pop();\n    }\n    check() {\n        return this.stack.length !== 0;\n    }\n    peek() {\n        return this.stack[this.stack.length - 1];\n    }\n}\nexport const stacks = {\n    int: new Stack(),\n    float: new Stack(),\n    str: new Stack(),\n    bool: new Stack(),\n};\n","import { stackTypes } from \"./stack.js\";\nimport { TSError } from \"./utils/error.js\";\nimport includes from \"./utils/includes.js\";\nexport default function typeCheck(program, functions, newFunctions) {\n    const programTypeErrors = traverseCheckProgram(program, {}, \"int\", functions);\n    let functionErrors = [];\n    for (const fn of newFunctions) {\n        // overload all `any` type parameters to the function type\n        const params = { ...functions[fn.type][fn.name].params };\n        if (fn.type !== \"any\") {\n            for (const param in params) {\n                if (params[param] === \"any\") {\n                    params[param] = fn.type;\n                }\n            }\n        }\n        const functionError = traverseCheckProgram(functions[fn.type][fn.name].body, params, fn.type, functions);\n        if (functionError.length > 0) {\n            functionErrors = [...functionErrors, ...functionError];\n        }\n    }\n    return [...programTypeErrors, ...functionErrors];\n}\nfunction traverseCheckProgram(program, otherIdentifiers, stack, functions) {\n    let errors = [];\n    for (const item of program) {\n        // if it is an expression\n        if (\"value\" in item) {\n            if (item.type === \"identifier\") {\n                // The identifier must be in the parameters or a function at the current stack, in the any stack or in each individual stack\n                const value = item.value;\n                if (value in otherIdentifiers) {\n                    stack = otherIdentifiers[value];\n                }\n                else if (!(value in functions[stack] ||\n                    value in functions.any ||\n                    (value in functions.int &&\n                        value in functions.float &&\n                        value in functions.str &&\n                        value in functions.bool))) {\n                    errors.push(new TSError({\n                        startPos: item.startPos,\n                        endPos: item.endPos,\n                    }, \"Attempt to call function not found at stack `{}`\", stack));\n                }\n            }\n            else if (item.type === \"keyword\") {\n                // certain keywords change the stack\n                if (includes(stackTypes, item.value)) {\n                    stack = item.value;\n                }\n                // Type values change the stack\n            }\n            else if (includes(stackTypes, item.type)) {\n                stack = item.type;\n            }\n        }\n        else {\n            // loops only need to check their block with the current type\n            if (item.type === \"loop\") {\n                const result = traverseCheckProgram(item.block, otherIdentifiers, stack, functions);\n                if (result.length > 0) {\n                    errors = [...errors, ...result];\n                }\n                // for loops need to check their block with the int type and change to the int type after\n            }\n            else if (item.type === \"forLoop\") {\n                const result = traverseCheckProgram(item.block, otherIdentifiers, \"int\", functions);\n                if (result.length > 0) {\n                    errors = [...errors, ...result];\n                }\n                stack = \"int\";\n                // while loops need to check their block with the bool type and change to the bool type after\n            }\n            else if (item.type === \"whileLoop\") {\n                const result = traverseCheckProgram(item.block, otherIdentifiers, \"bool\", functions);\n                if (result.length > 0) {\n                    errors = [...errors, ...result];\n                }\n                stack = \"bool\";\n                // if statements need to check their blocks with the bool type and turn it to the bool type after\n            }\n            else if (item.type === \"if\") {\n                const firstBlock = traverseCheckProgram(item.block, otherIdentifiers, \"bool\", functions);\n                if (item.else) {\n                    const secondBlock = traverseCheckProgram(item.else, otherIdentifiers, \"bool\", functions);\n                    errors = [...errors, ...firstBlock, ...secondBlock];\n                }\n                else {\n                    errors = [...errors, ...firstBlock];\n                }\n                stack = \"bool\";\n            }\n        }\n    }\n    return errors;\n}\n","export var ConsoleEffects;\n(function (ConsoleEffects) {\n    ConsoleEffects[\"Reset\"] = \"\\u001B[0m\";\n    ConsoleEffects[\"Bright\"] = \"\\u001B[1m\";\n    ConsoleEffects[\"Dim\"] = \"\\u001B[2m\";\n    ConsoleEffects[\"Underscore\"] = \"\\u001B[4m\";\n    ConsoleEffects[\"Blink\"] = \"\\u001B[5m\";\n    ConsoleEffects[\"Reverse\"] = \"\\u001B[7m\";\n    ConsoleEffects[\"Hidden\"] = \"\\u001B[8m\";\n    ConsoleEffects[\"FgBlack\"] = \"\\u001B[30m\";\n    ConsoleEffects[\"FgRed\"] = \"\\u001B[31m\";\n    ConsoleEffects[\"FgGreen\"] = \"\\u001B[32m\";\n    ConsoleEffects[\"FgYellow\"] = \"\\u001B[33m\";\n    ConsoleEffects[\"FgBlue\"] = \"\\u001B[34m\";\n    ConsoleEffects[\"FgMagenta\"] = \"\\u001B[35m\";\n    ConsoleEffects[\"FgCyan\"] = \"\\u001B[36m\";\n    ConsoleEffects[\"FgWhite\"] = \"\\u001B[37m\";\n    ConsoleEffects[\"BgBlack\"] = \"\\u001B[40m\";\n    ConsoleEffects[\"BgRed\"] = \"\\u001B[41m\";\n    ConsoleEffects[\"BgGreen\"] = \"\\u001B[42m\";\n    ConsoleEffects[\"BgYellow\"] = \"\\u001B[43m\";\n    ConsoleEffects[\"BgBlue\"] = \"\\u001B[44m\";\n    ConsoleEffects[\"BgMagenta\"] = \"\\u001B[45m\";\n    ConsoleEffects[\"BgCyan\"] = \"\\u001B[46m\";\n    ConsoleEffects[\"BgWhite\"] = \"\\u001B[47m\";\n})(ConsoleEffects || (ConsoleEffects = {}));\nexport function consoleEffect(str, ...effects) {\n    return `${effects.join(\"\")}${str}${ConsoleEffects.Reset}`;\n}\n","import { ConsoleEffects, consoleEffect } from \"./consoleEffect.js\";\nexport const ErrorInputConfig = {\n    input: \"\",\n    consoleFunc: console.log,\n};\nexport class TSError {\n    error;\n    message;\n    pos;\n    constructor(pos, msg, ...params) {\n        this.pos = pos;\n        const MAX_ERROR_WIDTH = 35; // characters on each side of the start of the error\n        let replaceNum = -1;\n        const formattedMessage = msg.replace(/{}/g, () => {\n            replaceNum += 1;\n            return params[replaceNum].toString();\n        });\n        this.message = formattedMessage;\n        let errorLine = ErrorInputConfig.input.split(\"\\n\")[pos.startPos.line - 1];\n        let errorStartsAt = pos.startPos.char - 1;\n        if (!(errorLine.length < MAX_ERROR_WIDTH * 2 + 1)) {\n            let newErrorLine = errorLine[pos.startPos.char - 1];\n            const textBefore = errorLine.substring(0, pos.startPos.char - 1);\n            const textAfter = errorLine.substring(pos.startPos.char);\n            if (textBefore.length >= MAX_ERROR_WIDTH) {\n                // need to trim off the start\n                errorStartsAt = 4 + MAX_ERROR_WIDTH;\n                newErrorLine =\n                    consoleEffect(\"... \", ConsoleEffects.Bright, ConsoleEffects.FgBlue) +\n                        textBefore.slice(-MAX_ERROR_WIDTH) +\n                        newErrorLine;\n            }\n            if (textAfter.length >= MAX_ERROR_WIDTH) {\n                // need to trim off the end\n                newErrorLine =\n                    newErrorLine +\n                        textAfter.slice(0, MAX_ERROR_WIDTH) +\n                        consoleEffect(\" ...\", ConsoleEffects.Bright, ConsoleEffects.FgBlue);\n            }\n            errorLine = newErrorLine;\n        }\n        let errorLength = pos.endPos.char - pos.startPos.char;\n        if (errorLength === 0) {\n            errorLength = 1;\n        }\n        if (pos.startPos.line !== pos.endPos.line) {\n            errorLength = MAX_ERROR_WIDTH + 1;\n        }\n        if (errorLength > MAX_ERROR_WIDTH + 1) {\n            errorLength = MAX_ERROR_WIDTH + 1;\n        }\n        const underline = consoleEffect(\"^\".repeat(errorLength), ConsoleEffects.FgRed, ConsoleEffects.Bright);\n        const error = consoleEffect(\"error\", ConsoleEffects.FgRed, ConsoleEffects.Bright);\n        const blueArrow = consoleEffect(\"-->\", ConsoleEffects.FgBlue, ConsoleEffects.Bright);\n        const bluePipe = consoleEffect(\"|\", ConsoleEffects.FgBlue, ConsoleEffects.Bright);\n        const blueLineNumber = consoleEffect(pos.startPos.line, ConsoleEffects.FgBlue, ConsoleEffects.Bright);\n        const lineNumberWidth = pos.startPos.line.toString().length;\n        const fullMessage = `\n${error}: ${consoleEffect(formattedMessage, ConsoleEffects.Bright)}\n${space(lineNumberWidth + 1)}${blueArrow} ${pos.startPos.line}:${pos.startPos.char}\n${space(lineNumberWidth + 1)}${bluePipe}\n${blueLineNumber} ${bluePipe} ${errorLine}\n${space(lineNumberWidth + 1)}${bluePipe} ${space(errorStartsAt)}${underline}`;\n        this.error = fullMessage;\n    }\n    fire() {\n        ErrorInputConfig.consoleFunc(this.error);\n    }\n}\nexport function isTSError(error) {\n    return error instanceof TSError;\n}\nfunction space(num) {\n    return \" \".repeat(num);\n}\n","export default function includes(arr, searchElement) {\n    return arr.some((e) => e === searchElement);\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.f = {};\n// This file contains only the entry chunk.\n// The chunk loading function for additional chunks\n__webpack_require__.e = (chunkId) => {\n\treturn Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {\n\t\t__webpack_require__.f[key](chunkId, promises);\n\t\treturn promises;\n\t}, []));\n};","// This function allow to reference async chunks\n__webpack_require__.u = (chunkId) => {\n\t// return url for filenames based on template\n\treturn \"\" + chunkId + \".extension.js\";\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import * as vscode from \"vscode\";\nimport { subscribeToDocumentChanges } from \"./diagnostics\";\nimport codeCompletion from \"./codeCompletion\";\nimport codeRunning from \"./codeRunning\";\n\nexport function activate(context: vscode.ExtensionContext) {\n  const parseAndTypeErrors =\n    vscode.languages.createDiagnosticCollection(\"parseAndTypeErrors\");\n  context.subscriptions.push(parseAndTypeErrors);\n  subscribeToDocumentChanges(context, parseAndTypeErrors);\n  codeCompletion(context);\n  codeRunning(context);\n}\n"],"names":["installedChunks","context","provider1","vscode","languages","registerCompletionItemProvider","async","document","position","token","keywordCompletions","map","e","CompletionItem","CompletionItemKind","Keyword","scanner","Scanner","getText","console","log","scan","parser","Parser","tokens","standardLibraryFunctions","parse","functions","functionNames","Object","keys","forEach","funcName","push","Set","Function","subscriptions","commands","registerCommand","window","terminals","show","activeTextEditor","save","Error","activeTerminal","createTerminal","sendText","fileName","showErrorMessage","refreshDiagnostics","doc","diagnosticCollection","diagnostics","fileText","errors","text","scanErrors","program","newFunctions","getErrors","TSError","createDiagnostic","error","set","uri","errorLength","pos","endPos","char","startPos","range","Range","line","diagnostic","Diagnostic","message","DiagnosticSeverity","code","onDidChangeActiveTextEditor","editor","workspace","onDidChangeTextDocument","onDidCloseTextDocument","delete","webpackAsyncContext","req","__webpack_require__","o","Promise","resolve","then","ids","id","module","exports","require","functionToText","name","stack","func","params","join","int","right","left","rawCode","stacks","bool","float","Math","floor","rand","max","min","random","wait","milliseconds","_","setTimeout","str","length","string","boolean","any","dup","first","drop","swap","second","over","rot","third","print","item","consoleFunc","toString","includes","toFixed","read","prompt","rl","input","process","stdin","output","stdout","answer","question","close","trim","isFloat","isInDecimal","split","parseFloat","parseInt","toStr","toBool","toInt","trunc","toFloat","pointer","constructor","this","block","value","default","key","isInRoot","isInLoop","isInFunction","type","current","puncTokens","literalTokens","mainTypeKeywords","atKeywords","innerBlock","elseBlock","else","isErrorWithFunction","typeKeywords","functionType","body","isExpected","keywords","trimEnd","ErrorInputConfig","strOfNumber","Number","isNaN","some","stackTypes","Stack","t","get","pop","check","peek","typeCheck","programTypeErrors","traverseCheckProgram","functionErrors","fn","param","functionError","otherIdentifiers","result","firstBlock","secondBlock","ConsoleEffects","consoleEffect","effects","Reset","msg","replaceNum","formattedMessage","replace","errorLine","errorStartsAt","MAX_ERROR_WIDTH","newErrorLine","textBefore","substring","textAfter","Bright","FgBlue","slice","underline","repeat","FgRed","blueArrow","bluePipe","blueLineNumber","lineNumberWidth","fullMessage","space","fire","isTSError","num","arr","searchElement","__webpack_module_cache__","moduleId","cachedModule","undefined","__webpack_modules__","m","d","definition","defineProperty","enumerable","f","chunkId","all","reduce","promises","u","obj","prop","prototype","hasOwnProperty","call","r","Symbol","toStringTag","chunk","moreModules","modules","chunkIds","runtime","i","installChunk","parseAndTypeErrors","createDiagnosticCollection","subscribeToDocumentChanges"],"sourceRoot":""}